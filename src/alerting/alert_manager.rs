use crate::analysis::AlertType;
use crate::config::Settings;
use crate::errors::DockManagerResult;
use chrono::{NaiveDateTime, Local, Duration};
use reqwest::Client;
use serde_json::json;
use std::sync::Arc;
use tokio::sync::Mutex;
use tracing::{info, error};

/// Represents different types of alerts that can be generated by the system
#[derive(Debug, Clone)]
pub enum Alert {
    /// Alert for a suspended door
    SuspendedDoor {
        door_name: String,
        duration: Duration,
        shipment_id: Option<String>,
    },
    /// Alert for a trailer pattern issue
    TrailerPatternIssue {
        door_name: String,
        issue: String,
        severity: i32,
        shipment_id: Option<String>,
    },
    /// Alert for a long loading start
    LongLoadingStart {
        door_name: String,
        shipment_id: String,
        duration: Duration,
    },
    /// Alert for a shipment that started loading but is not ready
    ShipmentStartedLoadNotReady {
        door_name: String,
        shipment_id: String,
        reason: String,
    },
    /// Alert for manual mode activation
    ManualModeAlert {
        door_name: String,
        shipment_id: Option<String>,
    },
    /// Alert for manual intervention timeout
    ManualInterventionTimeout {
        door_name: String,
        shipment_id: String,
        start_time: NaiveDateTime,
        end_time: NaiveDateTime,
    },
    /// Alert for a new shipment assigned while previous trailer is present
    NewShipmentPreviousTrailerPresent {
        dock_name: String,
        new_shipment: String,
        previous_shipment: Option<String>,
    },
    /// Alert for a trailer hostage situation
    TrailerHostage {
        door_name: String,
        shipment_id: Option<String>,
        duration: Duration,
    },
    TrailerDockedNotStarted {
        door_name: String,
        duration: Duration,
    },
    TrailerDocked {
        door_name: String,
        shipment_id: Option<String>,
        timestamp: NaiveDateTime,
        success: bool,
        failure_reason: Option<String>,
    },
    DockReady {
        door_name: String,
        shipment_id: Option<String>,
        timestamp: NaiveDateTime,
    },
    TrailerUndocked {
        door_name: String,
        shipment_id: Option<String>,
        timestamp: NaiveDateTime,
    },
}

/// Manages the creation and sending of alerts
pub struct AlertManager {
    /// Application settings
    settings: Arc<Settings>,
    /// HTTP client for sending alerts
    client: Client,
    /// Tracks the last alert time for each door to manage alert frequency
    alert_cooldown: Arc<Mutex<std::collections::HashMap<String, NaiveDateTime>>>,
}

impl AlertManager {
    /// Creates a new AlertManager instance
    ///
    /// # Arguments
    ///
    /// * `settings` - Application settings
    ///
    /// # Returns
    ///
    /// A new AlertManager instance
    pub fn new(settings: Arc<Settings>) -> Self {
        info!("Initializing Alert Manager");
        let client = Client::new();
        let alert_cooldown = Arc::new(Mutex::new(std::collections::HashMap::new()));
        Self { settings, client, alert_cooldown }
    }

    /// Handles an incoming alert
    ///
    /// # Arguments
    ///
    /// * `alert_type` - The type of alert to handle
    ///
    /// # Returns
    ///
    /// A Result indicating success or failure
    pub async fn handle_alert(&self, alert_type: AlertType) -> DockManagerResult<()> {
        info!("Handling Alert: {:#?}", alert_type);
        let alert = self.convert_alert_type(alert_type.clone());
        let (cooldown_key, repeat_interval) = match &alert.clone() {
            Alert::SuspendedDoor { door_name, .. } => (
                format!("suspended_door_{}", door_name),
                self.settings.alerts.suspended_door.repeat_interval,
            ),
            Alert::TrailerPatternIssue { door_name, .. } => (
                format!("trailer_pattern_{}", door_name),
                self.settings.alerts.trailer_pattern.repeat_interval,
            ),
            Alert::LongLoadingStart { door_name, .. } => (
                format!("long_loading_start_{}", door_name),
                self.settings.alerts.long_loading_start.repeat_interval,
            ),
            Alert::ShipmentStartedLoadNotReady { door_name, .. } => (
                format!("shipment_started_load_not_ready_{}", door_name),
                self.settings.alerts.shipment_started_load_not_ready.repeat_interval,
            ),
            Alert::TrailerHostage { door_name, .. } => (
                format!("trailer_hostage_{}", door_name),
                self.settings.alerts.trailer_hostage.repeat_interval,
            ),
            Alert::TrailerDocked { door_name, .. } => (
                format!("trailer_docked_{}", door_name),
                self.settings.alerts.trailer_docked.repeat_interval,
            ),
            Alert::DockReady { door_name, .. } => (
                format!("dock_ready_{}", door_name),
                self.settings.alerts.dock_ready.repeat_interval,
            ),
            Alert::TrailerUndocked { door_name, .. } => (
                format!("trailer_undocked_{}", door_name),
                self.settings.alerts.trailer_undocked.repeat_interval,
            ),
            // Add other cases as needed
            _ => (
                "default".to_string(),
                self.settings.alerts.suspended_door.repeat_interval, // Use a default interval
            ),
        };

        let should_alert = self.check_cooldown(&cooldown_key, repeat_interval).await;
        info!("Should Alert: {}, for alert: {:#?}", should_alert, alert_type);
        if should_alert {
            self.send_alert(alert).await?;
            self.update_cooldown(cooldown_key).await;
        }

        Ok(())
    }

    /// Sends an alert
    ///
    /// # Arguments
    ///
    /// * `alert` - The alert to send
    ///
    /// # Returns
    ///
    /// A Result indicating success or failure
    async fn send_alert(&self, alert: Alert) -> DockManagerResult<()> {
        let webhook_url = &self.settings.plants[0].alert_webhook_url;
        let alert_message = self.format_alert_message(&alert);

        let response = self.client.post(webhook_url)
            .json(&json!({
            "text": alert_message
        }))
            .send()
            .await
            .map_err(|e| crate::errors::DockManagerError::ConnectionError(e.to_string()))?;


        if response.status().is_success() {
            info!("Alert sent successfully: {:?}", alert);
        } else {
            error!("Failed to send alert: {:?}", alert);
        }

        Ok(())
    }

    /// Formats an alert into a message string
    ///
    /// # Arguments
    ///
    /// * `alert` - The alert to format
    ///
    /// # Returns
    ///
    /// A formatted alert message as a String
    pub fn format_alert_message(&self, alert: &Alert) -> String {
        match alert {
            Alert::SuspendedDoor { door_name, duration, shipment_id } => {
                format!("ðŸš¨ SUSPENDED DOOR ALERT: Door {} has been suspended for {}. Shipment ID: {}",
                        door_name, self.format_duration(duration), shipment_id.as_deref().unwrap_or("N/A"))
            },
            Alert::TrailerPatternIssue { door_name, issue, severity, shipment_id } => {
                format!("âš ï¸ TRAILER PATTERN ISSUE: Door {} - {}. Severity: {}. Shipment ID: {}",
                        door_name, issue, severity, shipment_id.as_deref().unwrap_or("N/A"))
            },
            Alert::LongLoadingStart { door_name, shipment_id, duration } => {
                format!("â³ LONG LOADING START: Door {} - Shipment {} has been in loading state for {} with no progress",
                        door_name, shipment_id, self.format_duration(duration))
            },
            Alert::ShipmentStartedLoadNotReady { door_name, shipment_id, reason } => {
                format!("ðŸ›‘ SHIPMENT STARTED LOAD NOT READY: Door {} - Shipment {} - Reason: {}",
                        door_name, shipment_id, reason)
            },
            Alert::ManualModeAlert { door_name, shipment_id } => {
                format!("ðŸ”§ MANUAL MODE ALERT: Door {} is in manual mode. Shipment ID: {}",
                        door_name, shipment_id.as_deref().unwrap_or("N/A"))
            },
            Alert::ManualInterventionTimeout { door_name, shipment_id, start_time, end_time } => {
                let duration = end_time.signed_duration_since(*start_time);
                format!("â° MANUAL INTERVENTION TIMEOUT: Door {} - Shipment {}. Duration: {}",
                        door_name, shipment_id, self.format_duration(&duration))
            },
            Alert::NewShipmentPreviousTrailerPresent { dock_name, new_shipment, previous_shipment } => {
                format!("ðŸš› NEW SHIPMENT, PREVIOUS TRAILER PRESENT: Door {} - New Shipment: {}, Previous Shipment: {}",
                        dock_name, new_shipment, previous_shipment.as_deref().unwrap_or("N/A"))
            },
            Alert::TrailerHostage { door_name, shipment_id, duration } => {
                format!("ðŸš¨ TRAILER HOSTAGE ALERT: Door {} has a trailer hostage for {}. Shipment ID: {}",
                        door_name, self.format_duration(duration), shipment_id.as_deref().unwrap_or("N/A"))
            },
            Alert::TrailerDockedNotStarted { door_name, duration } => {
                format!("â³ TRAILER DOCKED NOT STARTED: Door {} has had a trailer docked for {} without starting loading",
                        door_name, self.format_duration(duration))
            },
            Alert::TrailerDocked { door_name, shipment_id, timestamp, success, failure_reason } => {
                if *success {
                    format!("ðŸš› TRAILER DOCKED SUCCESSFULLY: Door {} - Shipment {} docked at {}",
                            door_name, shipment_id.as_deref().unwrap_or("N/A"), timestamp)
                } else {
                    format!("âš ï¸ TRAILER DOCKING FAILED: Door {} - Shipment {} failed to dock at {}. Reason: {}",
                            door_name, shipment_id.as_deref().unwrap_or("N/A"), timestamp, failure_reason.as_deref().unwrap_or("Unknown"))
                }
            },
            Alert::DockReady { door_name, shipment_id, timestamp } => {
                format!("âœ… DOCK READY: Door {} - Shipment {} is ready for loading at {}",
                        door_name, shipment_id.as_deref().unwrap_or("N/A"), timestamp)
            },
            Alert::TrailerUndocked { door_name, shipment_id, timestamp } => {
                format!("ðŸšš TRAILER UNDOCKED: Door {} - Shipment {} undocked at {}",
                        door_name, shipment_id.as_deref().unwrap_or("N/A"), timestamp)
            },
        }
    }

    /// Formats a duration into a human-readable string
    ///
    /// # Arguments
    ///
    /// * `duration` - The duration to format
    ///
    /// # Returns
    ///
    /// A formatted duration string
    pub fn format_duration(&self, duration: &Duration) -> String {
        let total_seconds = duration.num_seconds();
        let hours = total_seconds / 3600;
        let minutes = (total_seconds % 3600) / 60;
        let seconds = total_seconds % 60;

        if hours > 0 {
            format!("{}h {}m {}s", hours, minutes, seconds)
        } else if minutes > 0 {
            format!("{}m {}s", minutes, seconds)
        } else {
            format!("{}s", seconds)
        }
    }

    /// Converts an AlertType to an Alert
    ///
    /// # Arguments
    ///
    /// * `alert_type` - The AlertType to convert
    ///
    /// # Returns
    ///
    /// The corresponding Alert
    pub fn convert_alert_type(&self, alert_type: AlertType) -> Alert {
        match alert_type {
            AlertType::LongDockingTime(duration) => Alert::TrailerPatternIssue {
                door_name: "Unknown".to_string(),
                issue: format!("Long docking time: {}", self.format_duration(&duration)),
                severity: 1,
                shipment_id: None,
            },
            AlertType::ManualIntervention => Alert::ManualModeAlert {
                door_name: "Unknown".to_string(),
                shipment_id: None,
            },
            AlertType::TrailerHostage { door_name, shipment_id, duration } => Alert::TrailerHostage {
                door_name,
                shipment_id,
                duration,
            },
            AlertType::UnsafeDeparture => Alert::TrailerPatternIssue {
                door_name: "Unknown".to_string(),
                issue: "Unsafe departure detected".to_string(),
                severity: 3,
                shipment_id: None,
            },
            AlertType::ManualModeAlert { door_name, shipment_id } => Alert::ManualModeAlert {
                door_name,
                shipment_id,
            },
            AlertType::NewShipmentPreviousTrailerPresent { dock_name, new_shipment, previous_shipment, timestamp: _ } => {
                Alert::NewShipmentPreviousTrailerPresent {
                    dock_name,
                    new_shipment,
                    previous_shipment,
                }
            },
            AlertType::ManualInterventionTimeout { dock_name, shipment_id, start_time, end_time } => {
                Alert::ManualInterventionTimeout {
                    door_name: dock_name,
                    shipment_id,
                    start_time,
                    end_time,
                }
            },
            AlertType::SuspendedDoor { door_name, duration, shipment_id } => Alert::SuspendedDoor {
                door_name,
                duration,
                shipment_id,
            },
            AlertType::LongLoadingStart { door_name, shipment_id, duration } => Alert::LongLoadingStart {
                door_name,
                shipment_id,
                duration,
            },
            AlertType::ShipmentStartedLoadNotReady { door_name, shipment_id, reason } => Alert::ShipmentStartedLoadNotReady {
                door_name,
                shipment_id,
                reason,
            },
            AlertType::TrailerPatternIssue { door_name, issue, severity, shipment_id } => Alert::TrailerPatternIssue {
                door_name,
                issue,
                severity,
                shipment_id,
            },
            AlertType::TrailerDockedNotStarted { door_name, duration } => Alert::TrailerPatternIssue {
                door_name,
                issue: format!("Trailer docked but loading not started for {}", self.format_duration(&duration)),
                severity: 2,
                shipment_id: None,
            },
            AlertType::TrailerDocked { door_name, shipment_id, timestamp, success, failure_reason } => Alert::TrailerDocked {
                door_name,
                shipment_id,
                timestamp,
                success,
                failure_reason,
            },
            AlertType::DockReady { door_name, shipment_id, timestamp } => Alert::DockReady {
                door_name,
                shipment_id,
                timestamp,
            },
            AlertType::TrailerUndocked { door_name, shipment_id, timestamp } => Alert::TrailerUndocked {
                door_name,
                shipment_id,
                timestamp,
            },
        }
    }

    /// Checks if an alert should be sent based on the cooldown period
    ///
    /// # Arguments
    ///
    /// * `key` - The key identifying the alert
    /// * `repeat_interval` - The minimum time between alerts
    ///
    /// # Returns
    ///
    /// A boolean indicating whether the alert should be sent
    async fn check_cooldown(&self, key: &str, repeat_interval: u64) -> bool {
        let cooldown_map = self.alert_cooldown.lock().await;
        if let Some(last_sent) = cooldown_map.get(key) {
            let now = Local::now().naive_local();
            now.signed_duration_since(*last_sent) > Duration::seconds(repeat_interval as i64)
        } else {
            true
        }
    }


    /// Updates the cooldown time for an alert
    ///
    /// # Arguments
    ///
    /// * `alert_key` - The key identifying the alert
    async fn update_cooldown(&self, alert_key: String) {
        let mut cooldown_map = self.alert_cooldown.lock().await;
        cooldown_map.insert(alert_key, Local::now().naive_local());
    }
}