use crate::models::{DoorState, DockDoorEvent, DockDoor, DbInsert};
use chrono::{Duration, NaiveDateTime};
use std::sync::Arc;

/// The result of applying an analysis rule to a dock door event
#[derive(Debug, Clone)]
pub enum AnalysisResult {
    /// An alert to be triggered, with the specific alert type
    Alert(AlertType),
    /// A state transition for the dock door
    StateTransition(DoorState),
    /// A log entry to be recorded
    Log(LogEntry),
    /// A database insert operation to be performed
    DbInsert(DbInsert),
}

/// The different types of alerts that can be generated by analysis rules
#[derive(Debug, Clone)]
pub enum AlertType {
    /// The docking time has exceeded a defined threshold
    LongDockingTime(Duration),
    /// Manual intervention was required
    ManualIntervention,
    /// A trailer is being held hostage at the dock
    TrailerHostage,
    /// A trailer is departing under unsafe conditions
    UnsafeDeparture,
    /// Manual mode has been activated while a trailer is at the door
    ManualModeAlert,
    /// A new shipment is assigned while the previous trailer is still present
    NewShipmentPreviousTrailerPresent { 
        /// The name of the dock door
        dock_name: String, 
        /// The ID of the new shipment
        new_shipment: String, 
        /// The ID of the previous shipment (if any)
        previous_shipment: Option<String>, 
        /// The timestamp of the event
        timestamp: NaiveDateTime 
    },
    /// Manual intervention has timed out without resolving the issue
    ManualInterventionTimeout { 
        /// The name of the dock door
        dock_name: String, 
        /// The ID of the shipment
        shipment_id: String, 
        /// The start time of the manual intervention
        start_time: NaiveDateTime, 
        /// The end time (timeout) of the manual intervention
        end_time: NaiveDateTime 
    },
}

/// Represents different types of log entries that can be generated by analysis rules
#[derive(Debug, Clone)]
pub enum LogEntry {
    /// Logs the docking time for a shipment
    DockingTime {
        /// The timestamp of the log entry
        log_dttm: NaiveDateTime,
        /// The plant associated with the event
        plant: String,
        /// The name of the dock door
        door_name: String,
        /// The ID of the shipment (optional)
        shipment_id: Option<String>,
        /// The type of event being logged
        event_type: String,
        /// Whether the event was successful or not
        success: bool,
        /// Additional notes about the event
        notes: String,
        /// The severity level of the event
        severity: i32,
        /// The previous state before the event
        previous_state: Option<String>,
        /// The timestamp of the previous state
        previous_state_dttm: Option<NaiveDateTime>,
    },
    /// Logs the activation of manual mode for a dock door
    ManualModeActivated {
        /// The timestamp of the log entry
        log_dttm: NaiveDateTime,
        /// The plant associated with the event
        plant: String,
        /// The name of the dock door
        door_name: String,
        /// The ID of the shipment (optional)
        shipment_id: Option<String>,
        /// The type of event being logged
        event_type: String,
        /// Whether the event was successful or not
        success: bool,
        /// Additional notes about the event
        notes: String,
        /// The severity level of the event
        severity: i32,
        /// The previous state before the event
        previous_state: Option<String>,
        /// The timestamp of the previous state
        previous_state_dttm: Option<NaiveDateTime>,
    },
    /// Logs a change in the loading status of a shipment
    LoadingStatusChange {
        /// The timestamp of the log entry
        log_dttm: NaiveDateTime,
        /// The plant associated with the event
        plant: String,
        /// The name of the dock door
        door_name: String,
        /// The ID of the shipment (optional)
        shipment_id: Option<String>,
        /// The type of event being logged
        event_type: String,
        /// Whether the event was successful or not
        success: bool,
        /// Additional notes about the event
        notes: String,
        /// The severity level of the event
        severity: i32,
        /// The previous state before the event
        previous_state: Option<String>,
        /// The timestamp of the previous state
        previous_state_dttm: Option<NaiveDateTime>,
    },
    /// Logs when a shipment is unassigned from a door
    ShipmentUnassigned {
        /// The timestamp of the log entry
        log_dttm: NaiveDateTime,
        /// The plant associated with the event
        plant: String,
        /// The name of the dock door
        door_name: String,
        /// The ID of the shipment (optional)
        shipment_id: Option<String>,
        /// The type of event being logged
        event_type: String,
        /// Whether the event was successful or not
        success: bool,
        /// Additional notes about the event
        notes: String,
        /// The severity level of the event
        severity: i32,
        /// The previous state before the event
        previous_state: Option<String>,
        /// The timestamp of the previous state
        previous_state_dttm: Option<NaiveDateTime>,
    },
    /// Logs when a shipment is assigned to a door
    ShipmentAssigned {
        /// The timestamp of the log entry
        log_dttm: NaiveDateTime,
        /// The plant associated with the event
        plant: String,
        /// The name of the dock door
        door_name: String,
        /// The ID of the shipment (optional)
        shipment_id: Option<String>,
        /// The type of event being logged
        event_type: String,
        /// Whether the event was successful or not
        success: bool,
        /// Additional notes about the event
        notes: String,
        /// The severity level of the event
        severity: i32,
        /// The previous state before the event
        previous_state: Option<String>,
        /// The timestamp of the previous state
        previous_state_dttm: Option<NaiveDateTime>,
    },
    /// Logs when a new shipment is assigned to a door while the previous trailer is still present
    NewShipmentPreviousTrailerPresent {
        /// The timestamp of the log entry
        log_dttm: NaiveDateTime,
        /// The plant associated with the event
        plant: String,
        /// The name of the dock door
        door_name: String,
        /// The ID of the shipment (optional)
        shipment_id: Option<String>,
        /// The type of event being logged
        event_type: String,
        /// Whether the event was successful or not
        success: bool,
        /// Additional notes about the event
        notes: String,
        /// The severity level of the event
        severity: i32,
        /// The previous state before the event
        previous_state: Option<String>,
        /// The timestamp of the previous state
        previous_state_dttm: Option<NaiveDateTime>,
    },
    /// Logs the start of a manual intervention on a dock door
    ManualInterventionStarted {
        /// The timestamp of the log entry
        log_dttm: NaiveDateTime,
        /// The plant associated with the event
        plant: String,
        /// The name of the dock door
        door_name: String,
        /// The ID of the shipment (optional)
        shipment_id: Option<String>,
        /// The type of event being logged
        event_type: String,
        /// Whether the event was successful or not
        success: bool,
        /// Additional notes about the event
        notes: String,
        /// The severity level of the event
        severity: i32,
        /// The previous state before the event
        previous_state: Option<String>,
        /// The timestamp of the previous state
        previous_state_dttm: Option<NaiveDateTime>,
    },
    /// Logs a successful manual intervention on a dock door
    ManualInterventionSuccess {
        /// The timestamp of the log entry
        log_dttm: NaiveDateTime,
        /// The plant associated with the event
        plant: String,
        /// The name of the dock door
        door_name: String,
        /// The ID of the shipment (optional)
        shipment_id: Option<String>,
        /// The type of event being logged
        event_type: String,
        /// Whether the event was successful or not
        success: bool,
        /// Additional notes about the event
        notes: String,
        /// The severity level of the event
        severity: i32,
        /// The previous state before the event
        previous_state: Option<String>,
        /// The timestamp of the previous state
        previous_state_dttm: Option<NaiveDateTime>,
    },
    /// Logs a failed manual intervention on a dock door
    ManualInterventionFailure {
        /// The timestamp of the log entry
        log_dttm: NaiveDateTime,
        /// The plant associated with the event
        plant: String,
        /// The name of the dock door
        door_name: String,
        /// The ID of the shipment (optional)
        shipment_id: Option<String>,
        /// The type of event being logged
        event_type: String,
        /// Whether the event was successful or not
        success: bool,
        /// Additional notes about the event
        notes: String,
        /// The severity level of the event
        severity: i32,
        /// The previous state before the event
        previous_state: Option<String>,
        /// The timestamp of the previous state
        previous_state_dttm: Option<NaiveDateTime>,
    },
    /// Logs a change in the trailer's state at a dock door
    TrailerStateChange {
        /// The timestamp of the log entry
        log_dttm: NaiveDateTime,
        /// The plant associated with the event
        plant: String,
        /// The name of the dock door
        door_name: String,
        /// The ID of the shipment (optional)
        shipment_id: Option<String>,
        /// The type of event being logged
        event_type: String,
        /// Whether the event was successful or not
        success: bool,
        /// Additional notes about the event
        notes: String,
        /// The severity level of the event
        severity: i32,
        /// The previous state before the event
        previous_state: Option<String>,
        /// The timestamp of the previous state
        previous_state_dttm: Option<NaiveDateTime>,
    },
}

/// Defines the interface for analysis rules that can be applied to dock door events
pub trait AnalysisRule: Send + Sync {
    /// Applies the analysis rule to a dock door and an event, potentially generating `AnalysisResult`s
    fn apply(&self, dock_door: &DockDoor, event: &DockDoorEvent) -> Vec<AnalysisResult>;
}

/// Analyzes dock door events in context using a set of rules
#[derive(Default, Clone)]
pub struct ContextAnalyzer {
    /// The collection of analysis rules to apply
    rules: Vec<Arc<dyn AnalysisRule>>,
}

impl ContextAnalyzer {
    /// Creates a new `ContextAnalyzer` with no rules initially
    pub fn new() -> Self {
        ContextAnalyzer { rules: Vec::new() }
    }

    /// Adds an analysis rule to the analyzer
    pub fn add_rule(&mut self, rule: Arc<dyn AnalysisRule>) {
        self.rules.push(rule);
    }

    /// Analyzes a dock door event using the registered rules
    ///
    /// This method applies each rule in the `rules` vector to the given `dock_door` and `event`
    /// It collects the `AnalysisResult`s from all rules and returns them as a combined vector
    ///
    /// # Arguments
    ///
    /// * `dock_door`: The `DockDoor` object the event is associated with
    /// * `event`: The `DockDoorEvent` to be analyzed
    ///
    /// # Returns
    ///
    /// A vector of `AnalysisResult`s generated by applying the rules
    pub async fn analyze(&self, dock_door: &DockDoor, event: &DockDoorEvent) -> Vec<AnalysisResult> {
        let results: Vec<AnalysisResult>  = self.rules
            .iter()
            .flat_map(|rule| {
                let rule_results = rule.apply(dock_door, event);
                rule_results
            })
            .collect();
        results
    }
}

/// Creates a default `ContextAnalyzer` with no rules
pub fn create_default_analyzer() -> ContextAnalyzer {
    ContextAnalyzer::new()
}
