use std::sync::Arc;
use chrono::{NaiveDateTime, Local, Duration};
use dashmap::DashMap;
use serde::{Deserialize, Serialize};
use crate::analysis::context_analyzer::{AnalysisRule, AnalysisResult, AlertType, LogEntry};
use crate::models::{DockDoor, DockDoorEvent, LoadingStatus, TrailerState, ManualMode};
use log::{debug, info};

/// Configuration for the TrailerHostageRule
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TrailerHostageRuleConfig {
    /// The time threshold (in seconds) after which an alert should be triggered
    pub alert_threshold: u64,
    /// The interval (in seconds) at which repeat alerts should be sent
    pub repeat_interval: u64,
}

/// Rule for detecting and alerting on trailer hostage situations
pub struct TrailerHostageRule {
    /// The parsed configuration for this rule
    config: TrailerHostageRuleConfig,
    /// A map to track the last alert time for each door
    last_alert_time: Arc<DashMap<String, NaiveDateTime>>,
}

impl TrailerHostageRule {
    /// Creates a new TrailerHostageRule with the given configuration
    ///
    /// # Arguments
    ///
    /// * `config` - JSON configuration for the rule
    ///
    /// # Returns
    ///
    /// A new instance of TrailerHostageRule
    pub fn new(config: serde_json::Value) -> Self {
        let parsed_config: TrailerHostageRuleConfig = serde_json::from_value(config)
            .expect("Failed to parse TrailerHostageRule configuration");
        Self {
            config: parsed_config,
            last_alert_time: Arc::new(DashMap::new()),
        }
    }

    /// Checks if an alert should be sent based on the last alert time and repeat interval
    ///
    /// # Arguments
    ///
    /// * `door_name` - The name of the dock door
    ///
    /// # Returns
    ///
    /// A boolean indicating whether an alert should be sent
    fn should_send_alert(&self, door_name: &str) -> bool {
        let now = Local::now().naive_local();
        match self.last_alert_time.get(door_name) {
            Some(time) if now.signed_duration_since(*time) < Duration::seconds(self.config.repeat_interval as i64) => false,
            _ => {
                self.last_alert_time.insert(door_name.to_string(), now);
                true
            }
        }
    }

    /// Determines if a trailer hostage situation is occurring
    ///
    /// # Arguments
    ///
    /// * `dock_door` - The DockDoor to check
    ///
    /// # Returns
    ///
    /// A boolean indicating whether a hostage situation is occurring
    fn is_hostage_situation(&self, dock_door: &DockDoor) -> bool {
        (dock_door.loading_status == LoadingStatus::Completed ||
            dock_door.loading_status == LoadingStatus::WaitingForExit) &&
            dock_door.trailer_state == TrailerState::Docked &&
            dock_door.manual_mode == ManualMode::Enabled
    }

    /// Generates alert and log entry for a trailer hostage situation
    ///
    /// # Arguments
    ///
    /// * `dock_door` - The DockDoor with the hostage situation
    /// * `duration` - The duration of the hostage situation
    ///
    /// # Returns
    ///
    /// A vector of AnalysisResult items containing the alert and log entry
    fn generate_hostage_results(&self, dock_door: &DockDoor, duration: Duration) -> Vec<AnalysisResult> {
        let mut results = Vec::new();

        results.push(AnalysisResult::Alert(AlertType::TrailerHostage {
            door_name: dock_door.dock_name.clone(),
            shipment_id: dock_door.assigned_shipment.current_shipment.clone(),
            duration,
        }));

        let log_entry = LogEntry::TrailerHostage {
            log_dttm: Local::now().naive_local(),
            plant: dock_door.plant_id.clone(),
            door_name: dock_door.dock_name.clone(),
            shipment_id: dock_door.assigned_shipment.current_shipment.clone(),
            event_type: "TRAILER_HOSTAGE".to_string(),
            success: false,
            notes: format!("Trailer hostage situation detected. Duration: {:?}", duration),
            severity: 2,
            previous_state: None,
            previous_state_dttm: None,
        };
        results.push(AnalysisResult::Log(log_entry));

        results
    }
}

impl AnalysisRule for TrailerHostageRule {
    /// Applies the rule to a dock door event, generating appropriate analysis results
    ///
    /// This method analyzes the given event and generates relevant alerts and log entries
    /// based on the trailer hostage situation. It checks for hostage situations when the
    /// loading status changes to Completed or WaitingForExit, or when the manual mode is engaged.
    ///
    /// # Arguments
    ///
    /// * `dock_door` - The DockDoor associated with the event
    /// * `event` - The DockDoorEvent to analyze
    ///
    /// # Returns
    ///
    /// A vector of AnalysisResult items generated by applying the rule
    fn apply(&self, dock_door: &DockDoor, event: &DockDoorEvent) -> Vec<AnalysisResult> {
        match event {
            DockDoorEvent::LoadingStatusChanged(e) => {
                if (e.new_status == LoadingStatus::Completed || e.new_status == LoadingStatus::WaitingForExit)
                    && e.old_status == LoadingStatus::Loading {
                    info!("Loading status changed to {:?} for door: {}", e.new_status, dock_door.dock_name);
                    if self.is_hostage_situation(dock_door) {
                        debug!("Potential trailer hostage situation detected for door: {}", dock_door.dock_name);
                        // Initial detection, return results to add to monitoring queue
                        self.generate_hostage_results(dock_door, Duration::seconds(0))
                    } else {
                        Vec::new()
                    }
                } else {
                    Vec::new()
                }
            },
            DockDoorEvent::SensorStateChanged(e) if e.sensor_name == "RH_MANUAL_MODE" && e.new_value == Some(1) => {
                if self.is_hostage_situation(dock_door) {
                    let duration = dock_door.trailer_state_changed
                        .map(|t| Local::now().naive_local().signed_duration_since(t))
                        .unwrap_or_else(|| Duration::seconds(0));

                    if duration > Duration::seconds(self.config.alert_threshold as i64) &&
                        self.should_send_alert(&dock_door.dock_name) {
                        debug!("Trailer hostage situation confirmed for door: {}", dock_door.dock_name);
                        self.generate_hostage_results(dock_door, duration)
                    } else {
                        Vec::new()
                    }
                } else {
                    Vec::new()
                }
            },
            _ => Vec::new()
        }
    }
}